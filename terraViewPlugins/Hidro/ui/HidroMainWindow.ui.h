/******************************************************************************
* Hidro development team
* 
* Terra View Hidro Plugin
* 
* @(#) HidroMainWindow.h
*
*******************************************************************************
*
* $Rev: 8882 $:
*
* $Author: alexcj $:
*
* $Date: 2010-08-30 23:15:59 +0300 (ma, 30 elo 2010) $:
*
******************************************************************************/

/*!
	\brief This is the Hidro Interfaces Group.
	@defgroup hidroInterface The Group for Plugin Interaction.
*/

/** 
  * \file HidroMainWindow.ui.h
  *
  * \class HidroMainWindow
  *
  * \brief This file is a interface generated by qt designer
  *
  * This interface is the main interface from hidro application, 
  * will be used to manipulate graphs (create, load and save in 
  * terraLib database). Also will be used to execute algorithms
  * over the graph.
  *
  * \author Eric Silva Abreu <eric.abreu@funcate.org.br>
  * \version 1.0
  *
/*!
  @ingroup hidroInterface
 */

/*
** ----------------------------------------------------------------------------
** Includes:
*/
#include <TeDatabase.h>
#include <TeTheme.h>
#include <TeView.h>
#include <TeLayer.h>
#include <TeProjection.h>

#include <HidroPersister.h>
#include <HidroMetadata.h>
#include <HidroUtils.h>
#include <HidroGraph.h>
#include <HidroEdge.h>
#include <HidroVertex.h>

#include <HidroBoostUtils.h>
#include <HidroFlowUtils.h>
#include <HidroFlowDEM8Connected.h>
#include <HidroFlowD8.h>

#include <HidroUpscale.h>
#include <HidroConvexHull.h>

#include <HidroBoostParams.h>
#include <HidroBoostAlgorithmFactory.h>

#include <qmessagebox.h>
#include <qcombobox.h>
#include <qlineedit.h>

/** \brief HidroMainWindow init function.
    * Used to replace de default constructor from interface;
	* \param parameters		Input parameter used to set the parameters from app
	* \return				True if the input parameters are valids and False in other case.
    */
bool HidroMainWindow::init( PluginParameters* parameters )
{
    if(parameters == NULL)
	{
		return false;
	}

	_parameters = parameters;

//list all layers from current database
	listLayers();

//list all graphs from current database
	listGraphs();

//list all flow algorithms implemented
	listFlowAlgorithms();

//list post processing algorithms names
	listPostProcessingAlgorithms();

//list boost algorithms
	listBoostAlgorithms();

//boost interfaces
	_uiConnectedComponents = NULL;
	_uiDijkstra = NULL;
	_uiSearch = NULL;
	_uiBidirGraph = NULL;
	_maskWindow = NULL;

//convert interface defaults
	inputTerraHidroRadioButton_clicked();
	outputHandRadioButton_clicked();

	return true;
}

/** \brief HidroMainWindow destroy function.
    * Used to replace de default destructor from interface;
    */
void HidroMainWindow::destroy()
{
	if(_uiConnectedComponents)
	{
		delete _uiConnectedComponents;
		_uiConnectedComponents = 0;
	}

	if(_uiDijkstra)
	{
		delete _uiDijkstra;
		_uiDijkstra = 0;
	}

	if(_uiSearch)
	{
		delete _uiSearch;
		_uiSearch = 0;
	}

	if(_uiBidirGraph)
	{
		delete _uiBidirGraph;
		_uiBidirGraph = 0;
	}

	if(_maskWindow)
	{
		delete _maskWindow;
		_maskWindow = 0;
	}
}

/** \brief HidroMainWindow listLayers function.
    * Used to list all layer names from current database
	* that has TeRASTER representation inside a combo box
	* in interface.
    */
void HidroMainWindow::listLayers()
{
	if(!_parameters->getCurrentDatabasePtr())
	{
		return;
	}

//clear all layers names inside the combo box
    inputLayerComboBox->clear();
	inputLayerComboBox->insertItem("");

	flowInputLayerComboBox->clear();
	flowInputLayerComboBox->insertItem("");

	upScaleInputLayerComboBox->clear();
	upScaleInputLayerComboBox->insertItem("");

	maskInputLayerComboBox->clear();
	maskInputLayerComboBox->insertItem("");

	converterInputLDDComboBox->clear();
	converterInputLDDComboBox->insertItem("");

	HidroUtils utils(_parameters->getCurrentDatabasePtr());

	std::vector<std::string> layerNames = utils.listLayers(true, false);

	for(unsigned int i = 0; i < layerNames.size(); ++i)
	{
		flowInputLayerComboBox->insertItem(layerNames[i].c_str());
		inputLayerComboBox->insertItem(layerNames[i].c_str());
		upScaleInputLayerComboBox->insertItem(layerNames[i].c_str());
		maskInputLayerComboBox->insertItem(layerNames[i].c_str());
		converterInputLDDComboBox->insertItem(layerNames[i].c_str());
	}
}


/** \brief HidroMainWindow listGraphs function.
    * Used to list all graph names from current database
	* inside a combo box in interface.
    */
void HidroMainWindow::listGraphs()
{
	graphNameComboBox->clear();
	graphNameUpScaleComboBox->clear();
	maskGraphNameComboBox->clear();

	HidroMetadata metadata(_parameters->getCurrentDatabasePtr());

	std::vector<std::string> graphList = metadata.getGraphNameListFromDB();

	graphNameComboBox->insertItem("");
	graphNameUpScaleComboBox->insertItem("");
	maskGraphNameComboBox->insertItem("");

	for(unsigned int i =0; i < graphList.size(); ++i)
	{
		graphNameComboBox->insertItem(graphList[i].c_str());
		graphNameUpScaleComboBox->insertItem(graphList[i].c_str());
		maskGraphNameComboBox->insertItem(graphList[i].c_str());
	}
}

/** \brief HidroMainWindow listFlow Algorithms function.
    * Used to list all flow algorithms to extract flow and put
	* inside a combo box in interface.
    */
void HidroMainWindow::listFlowAlgorithms()
{
	flowAlgorithmComboBox->clear();

	std::vector<std::string> flowAlgorithms = getHidroFlowAlgorithms();

	for(unsigned int i = 0; i < flowAlgorithms.size(); ++i)
	{
		flowAlgorithmComboBox->insertItem(flowAlgorithms[i].c_str());
	}
}

void HidroMainWindow::listPostProcessingAlgorithms()
{
	postProcessingComboBox->clear();

	//postProcessingComboBox->insertItem("");
	//postProcessingComboBox->insertItem("Pit Correction - Median");
	postProcessingComboBox->insertItem("Pit Correction - Media");
  postProcessingComboBox->insertItem("Pit Correction - Media Queue");

  postProcessingComboBox->setCurrentText("Pit Correction - Media Queue");
}

/** \brief HidroMainWindow listBoost Algorithms function.
    * Used to list all boost algorithms implemented in terra hidro plugin
	* inside a combo box in interface.
    */
void HidroMainWindow::listBoostAlgorithms()
{
	algorithmComboBox->clear();
	//algorithmComboBox->insertItem("");

	std::vector<std::string> boostAlgorithms = getBoostAlgorithmsNames();

	for(unsigned int i = 0; i < boostAlgorithms.size(); ++i)
	{
		algorithmComboBox->insertItem(boostAlgorithms[i].c_str());
	}

  algorithmComboBox->setCurrentText( boostAlgorithms[0].c_str() );
}

/** \brief HidroMainWindow checkLayerName function.
    * Used to check the input layer name defined by user in interface
	* the name can not be exist in database and has to be a valid name.
	* \return	True if the name is valid and False in other case
    */
bool HidroMainWindow::checkLayerName(std::string layerName)
{
	if(!_parameters->getCurrentDatabasePtr())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Database not found."));
		return false;
	}

	HidroUtils utils(_parameters->getCurrentDatabasePtr());

	std::string errorMessage = "";

	if(!utils.checkLayerName(layerName, errorMessage))
	{
		QMessageBox::warning(this, tr("Warning"), errorMessage.c_str());
		return false;
	}

	return true;   
}

/** \brief HidroMainWindow interface button Create.
    * Used to create a new flow in terraLib database from a input
	* layer with TeRASTER representation. It's necessary to define
	* the output layer name to execute this operation.
    */
void HidroMainWindow::flowGeneratePushButton_clicked()
{
	//check input parameters from interface
	if(flowInputLayerComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Input Layer not defined."));
		return;
	}

	if(flowOutputLayerNameLineEdit->text().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Output Layer name not defined."));
		return;
	}

	if(!checkLayerName(flowOutputLayerNameLineEdit->text().latin1()))
	{
		return;
	}

	TeLayer* inputLayer = NULL;

	HidroUtils utils(_parameters->getCurrentDatabasePtr());

	inputLayer = utils.getLayerByName(flowInputLayerComboBox->currentText().latin1());

	if(!inputLayer)
	{
		QMessageBox::warning(this, tr("Warning"), tr("Error getting layer from database."));
		return;
	}

//execute operation
	if(flowDemRadioButton->isChecked())
	{
		std::string algorithm = flowAlgorithmComboBox->currentText().latin1();		

	//post processing
		//bool pitcorrec = false;
		std::string postProcName = postProcessingComboBox->currentText().latin1();
		std::string layerName = flowInputLayerComboBox->currentText().latin1();
		TeDatabase* db = _parameters->getCurrentDatabasePtr();
    int treatmentMax = treatmentMaxSpinBox->value();    

    double boost = boostLineEdit->text().toDouble();

    std::string lddName = flowOutputLayerNameLineEdit->text().latin1();

	//create view
		TeProjection* proj = TeProjectionFactory::make(inputLayer->projection()->params());

		std::string viewName = flowOutputLayerNameLineEdit->text().latin1();
					viewName += "_view";

		int id = 0;
		while(db->viewExist(viewName))
		{
			id++;
			viewName = viewName + Te2String(id, 0);
		}

		TeView* view = new TeView(viewName, db->user());
		view->projection(proj);

		if(!db->insertView(view))
		{
			delete view;
			return;
		}

    if( !inputLayer->hasGeometry( TeRASTER ) )
    {
      QMessageBox::warning(this, tr("Warning"), tr("inputLayer nao tem teraster."));

      return;
    }

		if(algorithm == HIDRO_FLOW_DEM_8D_COMMON_FLOW_NEW)
		{
			if(!generateFlowD8(db, view, inputLayer, layerName, postProcName, treatmentMax, boost, lddName))
			{
				QMessageBox::warning(this, tr("Warning"), tr("Error generating flow."));
				return;
			}
		}


    // Agora é salvo no HidroFlowD8.cpp
    // Fiz isso para caso caia depois de ter feito a correção de fossos o LDD ja esteja salvo.
    // Alexandre.
		/*HidroUtils utils(_parameters->getCurrentDatabasePtr());
		if(!utils.saveOutputRasterCreatingTheme(flowOutputLayerNameLineEdit->text().latin1(), rasterOut, view))
		{
			QMessageBox::warning(this, tr("Warning"), tr("Error importing raster."));

			rasterOut->clear();
			delete rasterOut;

			return;
		}*/    
	}

//list all layers from current database
	listLayers();

	_parameters->updateTVInterface();

	QMessageBox::information(this, tr("Information"), tr("Flow Created."));
}

/** \brief HidroMainWindow interface button Generate.
    * Used to create a new graph in terraLib database from a input
	* layer with TeRASTER representation. It's necessary to define
	* the output layer name to execute this operation.
    */
void HidroMainWindow::generatePushButton_clicked()
{
//check input parameters from interface
	if(inputLayerComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Input Layer not defined."));
		return;
	}

	if(outputLayerNameLineEdit->text().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Output Layer name not defined."));
		return;
	}

	if(!checkLayerName(outputLayerNameLineEdit->text().latin1()))
	{
		return;
	}

	TeLayer* inputLayer = NULL;

	HidroUtils utils(_parameters->getCurrentDatabasePtr());

	inputLayer = utils.getLayerByName(inputLayerComboBox->currentText().latin1());

	if(!inputLayer || !inputLayer->raster())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Error getting layer from database."));
		return;
	}

	TeProjection* proj = TeProjectionFactory::make(inputLayer->projection()->params());

//generate graph
	HidroGraph graph(outputLayerNameLineEdit->text().latin1());

	if(!utils.generateGraph(inputLayer->raster(), graph))
	{
		QMessageBox::warning(this, tr("Warning"), tr("Error generating graph."));
		return;
	}

//persister graph
	HidroPersister persister(_parameters->getCurrentDatabasePtr());
	if(!persister.saveGraphInDatabase(graph, proj, inputLayer->raster()->params().resx_))
	{
		QMessageBox::warning(this, tr("Warning"), persister.getErrorMessage().c_str());
		return;
	}

//preview terralib objects
  // Alexandre
	//std::string mess = "Do you really want to create graph view? \n This operation can take a few minutes.";
	//int res = QMessageBox::question(this, tr("Create View"), tr(mess.c_str()), tr("&Yes"), tr("&No"));

  int res = 0;

	if(res == 0)
	{
		if(!persister.createGraphView(&graph, proj))
		{
			QMessageBox::warning(this, tr("Warning"), persister.getErrorMessage().c_str());
			return;
		}

		_parameters->updateTVInterface();
	}

	listGraphs();

	QMessageBox::information(this, tr("Information"), tr("Graph Generated."));
}

/** \brief HidroMainWindow interface button Delete.
    * Used to delete a graph from current database.
	* This operation also will be delete from database
	* the layer points (vertex) and layer lines (edges)
	* from this graph.
    */
void HidroMainWindow::deletePushButton_clicked()
{
	if(graphNameComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Graph not selected."));
		return;
	}

	int response = QMessageBox::question(this, tr("Delete Graph"),
		tr("Do you really want to delete selected graph from database:") + " " + graphNameComboBox->currentText() + "?",
			 tr("Yes"), tr("No"));

	if (response != 0)
		return;

//verify if graph exist
	HidroMetadata metadata(_parameters->getCurrentDatabasePtr());
	if(!metadata.existGraph(graphNameComboBox->currentText().latin1()))
	{
		QMessageBox::warning(this, tr("Warning"), tr("Graph not found in database."));
		return;
	}

//remove graph and layers
	HidroPersister persister(_parameters->getCurrentDatabasePtr());
	if(!persister.deleteGraphFromDatabase(graphNameComboBox->currentText().latin1()))
	{
		QMessageBox::warning(this, tr("Warning"), persister.getErrorMessage().c_str());
		return;
	}

	listGraphs();

	_parameters->updateTVInterface();

	QMessageBox::warning(this, tr("Warning"), tr("Graph removed from database."));
}

/** \brief HidroMainWindow interface button Execute.
    * Used to execute a selected boost algorithm over
	* a selected graph.
    */
void HidroMainWindow::executePushButton_clicked()
{
//verify interface parameters
	if(graphNameComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Graph name not defined."));
		return;
	}

//get algorithm name
	if(algorithmComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Algorithm Name not defined."));
		return;
	}

	std::string boostAalgorithm = algorithmComboBox->currentText().latin1();

	if(boostAalgorithm == "Connected Components")
	{
		if(_uiConnectedComponents)
		{
			delete _uiConnectedComponents;
		}

		_uiConnectedComponents = new HidroBoostUIConnectedComponents(this, "CC", true);

		if(_uiConnectedComponents->init(_parameters, false))
		{
			_uiConnectedComponents->setGraphName(graphNameComboBox->currentText().latin1());
			_uiConnectedComponents->exec();

			delete _uiConnectedComponents;
			_uiConnectedComponents = NULL;
		}
	}
	else if(boostAalgorithm == "Strongly Connected Components")
	{
		if(_uiConnectedComponents)
		{
			delete _uiConnectedComponents;
		}

		_uiConnectedComponents = new HidroBoostUIConnectedComponents(this, "CC", true);

		if(_uiConnectedComponents->init(_parameters, true))
		{
			_uiConnectedComponents->setGraphName(graphNameComboBox->currentText().latin1());
			_uiConnectedComponents->exec();

			delete _uiConnectedComponents;
			_uiConnectedComponents = NULL;
		}
	}
	else if(boostAalgorithm == "Breadth First Search")
	{
		if(_uiSearch)
		{
			delete _uiSearch;
		}

		_uiSearch = new HidroBoostUISearch(this, "Search Algorithms", false);

		if(_uiSearch->init(_parameters, true))
		{
			_uiSearch->setGraphName(graphNameComboBox->currentText().latin1());
			_uiSearch->show();
		}
	}
	else if(boostAalgorithm == "Dijkstra Shortest Path")
	{
		if(_uiDijkstra)
		{
			delete _uiDijkstra;
		}

		_uiDijkstra = new HidroBoostUIDijkstra(this, "Dijkstra", false);

		if(_uiDijkstra->init(_parameters))
		{
			_uiDijkstra->setGraphName(graphNameComboBox->currentText().latin1());
			_uiDijkstra->show();
		}
	}
	else if(boostAalgorithm == "Bidirectional Graph")
	{
		if(_uiBidirGraph)
		{
			delete _uiBidirGraph;
		}

		_uiBidirGraph = new HidroBoostUIBidirectionalGraph(this, "Bidirectional Graph", false);

		if(_uiBidirGraph->init(_parameters, true))
		{
			_uiBidirGraph->setGraphName(graphNameComboBox->currentText().latin1());
			_uiBidirGraph->show();
		}
	}
	else if(boostAalgorithm == "Incidence Graph")
	{
		if(_uiBidirGraph)
		{
			delete _uiBidirGraph;
		}

		_uiBidirGraph = new HidroBoostUIBidirectionalGraph(this, "Bidirectional Graph", false);

		if(_uiBidirGraph->init(_parameters, false))
		{
			_uiBidirGraph->setGraphName(graphNameComboBox->currentText().latin1());
			_uiBidirGraph->show();
		}
	}
}

void HidroMainWindow::algorithmComboBox_activated( const QString & value )
{
	bglTextEdit->clear();

	if(value.isEmpty())
	{
		return;
	}

	std::string boostAalgorithm = value.latin1();

	HidroBoostParams pBoost;

	if(boostAalgorithm == "Connected Components")
	{
		pBoost._boostAlgorithmName = "Connected Components";
	}
	else if(boostAalgorithm == "Strongly Connected Components")
	{
		pBoost._boostAlgorithmName = "Strongly Connected Components";
	}
	else if(boostAalgorithm == "Breadth First Search")
	{
		pBoost._boostAlgorithmName = "Breadth First Search";
	}
	else if(boostAalgorithm == "Dijkstra Shortest Path")
	{
		pBoost._boostAlgorithmName = "Dijkstra Shortest Path";
	}
	else if(boostAalgorithm == "Bidirectional Graph")
	{
		pBoost._boostAlgorithmName = "Bidirectional Graph";
	}
	else if(boostAalgorithm == "Incidence Graph")
	{
		pBoost._boostAlgorithmName = "Incidence Graph";
	}

	HidroBoostAlgorithms* aBoost = HidroBoostAlgorithmFactory::make(pBoost);

	if(aBoost)
	{
		std::string algorithmDescritpion = aBoost->getBGLalgorithmDescription();

		bglTextEdit->setText(algorithmDescritpion.c_str());
	}
}

void HidroMainWindow::okUpScalePushButton_clicked()
{
//verify interface parameters
	if(graphNameUpScaleComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Graph name not defined."));
		return;
	}

	if(upScaleInputLayerComboBox->currentText().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Input Layer not defined."));
		return;
	}

	if(cotatLineEdit->text().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Threshold COTAT value not defined."));
		return;
	}

	bool okCotat = false;

	int cotatValue = cotatLineEdit->text().toInt(&okCotat);

	if(!okCotat)
	{
		QMessageBox::warning(this, tr("Warning"), tr("Threshold COTAT invalid value."));
		return;
	}

	if(mufpLineEdit->text().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Threshold MUFP value not defined."));
		return;
	}

	bool okMufp = false;

	int mufpValue = mufpLineEdit->text().toInt(&okMufp);

	if(!okMufp)
	{
		QMessageBox::warning(this, tr("Warning"), tr("Threshold MUFP invalid value."));
		return;
	}

	if(outputGraphNameLineEdit->text().isEmpty())
	{
		QMessageBox::warning(this, tr("Warning"), tr("Output graph name not defined."));
		return;
	}

//execute upscaling
	HidroUpscale upScale(_parameters->getCurrentDatabasePtr());

	if(!upScale.generateUpscale(graphNameUpScaleComboBox->currentText().latin1(), 
							upScaleInputLayerComboBox->currentText().latin1(),
							cotatValue,
							mufpValue))
	{
		QMessageBox::warning(this, tr("Warning"), upScale.errorMessage().c_str());
		return;
	}


//persister graph
	HidroGraph* graph = upScale.getOutputGraph();

	std::string graphName = outputGraphNameLineEdit->text();

	graph->setGraphName(graphName);

	if(graph && graph->isGraphValid())
	{

		//get input layer grid
		TeLayer* inputLayer = NULL;

		HidroUtils utils(_parameters->getCurrentDatabasePtr());

		inputLayer = utils.getLayerByName(upScaleInputLayerComboBox->currentText().latin1());

		TeProjection* proj = TeProjectionFactory::make(inputLayer->projection()->params());


		HidroPersister persister(_parameters->getCurrentDatabasePtr());
		if(!persister.saveGraphInDatabase(*graph, proj, inputLayer->raster()->params().resx_))
		{
			QMessageBox::warning(this, tr("Warning"), persister.getErrorMessage().c_str());
			return;
		}

		//preview terralib objects
		std::string mess = "Do you really want to create graph view? \n This operation can take a few minutes.";
		int res = QMessageBox::question(this, tr("Create View"), tr(mess.c_str()), tr("&Yes"), tr("&No"));

		if(res == 0)
		{
			if(!persister.createGraphView(graph, proj))
			{
				QMessageBox::warning(this, tr("Warning"), persister.getErrorMessage().c_str());
				return;
			}

			_parameters->updateTVInterface();
		}

		listGraphs();

		QMessageBox::information(this, tr("Information"), tr("Graph Generated."));
	}
}

void HidroMainWindow::generateMaskPushButton_clicked()
{
//check input parameters
	if(maskGraphNameComboBox->currentText().isEmpty())
	{
		return;
	}
	std::string graphName = maskGraphNameComboBox->currentText().latin1();

	if(maskInputLayerComboBox->currentText().isEmpty())
	{
		return;
	}
	std::string inputLayer = maskInputLayerComboBox->currentText().latin1();

	if(maskOutputLayerNameLineEdit->text().isEmpty())
	{
		return;
	}
	std::string outputLayerName = maskOutputLayerNameLineEdit->text().latin1();

//load graph
	HidroPersister persister(_parameters->getCurrentDatabasePtr());

	HidroGraph inputGraph;

	if(!persister.loadGraphFromDatabase(graphName, inputGraph))
	{
		return;
	}

//load layer
	HidroUtils utils(_parameters->getCurrentDatabasePtr());

	TeLayer* layer = utils.getLayerByName(inputLayer);

	if(!layer)
	{
		return;
	}

//generate mask
	HidroConvexHull cHull(_parameters->getCurrentDatabasePtr());

	TeLayer* layerMask = cHull.generateMask(&inputGraph, layer->raster(), outputLayerName);

	if(!layerMask)
	{
		return;
	}

//generate pols
	if(bool generatePols = generatePolsCheckBox->isChecked())
	{
		TeLayer* layerPols = cHull.generatePols(layerMask->raster(), outputLayerName);

		if(!layerPols)
		{
			return;
		}
	}

	_parameters->updateTVInterface();
}

void HidroMainWindow::editMaskPushButton_clicked()
{
	if(_maskWindow)
	{
		delete _maskWindow;
	}

	_maskWindow = new HidroMaskWindow(this, "Edit Mask", false);

	_maskWindow->init(_parameters);

	_maskWindow->show();
}


void HidroMainWindow::inputTerraHidroRadioButton_clicked()
{
	inputUPLEFTLineEdit->setText( "32" );   
	inputUPTLineEdit->setText( "64" );
	inputUPRIGHTLineEdit->setText( "128" );
	inputLEFTLineEdit->setText( "16" );
	inputPITLineEdit->setText( "0" );
	inputRIGHTLineEdit->setText( "1" );
	inputDOWNLEFTLineEdit->setText( "8" );
	inputDOWNTLineEdit->setText( "4" );
	inputDOWNRIGHTLineEdit->setText( "2" );
	inputDUMMYLineEdit->setText( "255" );

   inputUseDummyCheckBox->setChecked( true );
}

void HidroMainWindow::inputHandRadioButton_clicked()
{
	inputUPLEFTLineEdit->setText( "8" );
	inputUPTLineEdit->setText( "5" );
	inputUPRIGHTLineEdit->setText( "3" );
	inputLEFTLineEdit->setText( "7" );
	inputPITLineEdit->setText( "0" );
	inputRIGHTLineEdit->setText( "2" );
	inputDOWNLEFTLineEdit->setText( "6" );
	inputDOWNTLineEdit->setText( "4" );
	inputDOWNRIGHTLineEdit->setText( "1" );
	inputDUMMYLineEdit->setText( "0" );

   inputUseDummyCheckBox->setChecked( false );
}

void HidroMainWindow::inputMGBRadioButton_clicked()
{
	inputUPLEFTLineEdit->setText( "64" );
	inputUPTLineEdit->setText( "128" );
	inputUPRIGHTLineEdit->setText( "1" );
	inputLEFTLineEdit->setText( "32" );
	inputPITLineEdit->setText( "0" );
	inputRIGHTLineEdit->setText( "2" );
	inputDOWNLEFTLineEdit->setText( "16" );
	inputDOWNTLineEdit->setText( "8" );
	inputDOWNRIGHTLineEdit->setText( "4" );
	inputDUMMYLineEdit->setText( "-9999" );

   inputUseDummyCheckBox->setChecked( true );
}

void HidroMainWindow::inputCustomRadioButton_clicked()
{
	inputUPLEFTLineEdit->setText( "" );
	inputUPTLineEdit->setText( "" );
	inputUPRIGHTLineEdit->setText( "" );
	inputLEFTLineEdit->setText( "" );
	inputPITLineEdit->setText( "" );
	inputRIGHTLineEdit->setText( "" );
	inputDOWNLEFTLineEdit->setText( "" );
	inputDOWNTLineEdit->setText( "" );
	inputDOWNRIGHTLineEdit->setText( "" );
	inputDUMMYLineEdit->setText( "" );

   inputUseDummyCheckBox->setChecked( false );
}

void HidroMainWindow::outputTerraHidroRadioButton_clicked()
{	
	outputUPLEFTLineEdit->setText( "32" );
	outputUPTLineEdit->setText( "64" );
	outputUPRIGHTLineEdit->setText( "128" );
	outputLEFTLineEdit->setText( "16" );
	outputPITLineEdit->setText( "0" );
	outputRIGHTLineEdit->setText( "1" );
	outputDOWNLEFTLineEdit->setText( "8" );
	outputDOWNTLineEdit->setText( "4" );
	outputDOWNRIGHTLineEdit->setText( "2" );
	outputDUMMYLineEdit->setText( "255" );

   outputUseDummyCheckBox->setChecked( true );
}

void HidroMainWindow::outputHandRadioButton_clicked()
{
	outputUPLEFTLineEdit->setText( "8" );
	outputUPTLineEdit->setText( "5" );
	outputUPRIGHTLineEdit->setText( "3" );
	outputLEFTLineEdit->setText( "7" );
	outputPITLineEdit->setText( "0" );
	outputRIGHTLineEdit->setText( "2" );
	outputDOWNLEFTLineEdit->setText( "6" );
	outputDOWNTLineEdit->setText( "4" );
	outputDOWNRIGHTLineEdit->setText( "1" );
	outputDUMMYLineEdit->setText( "0" );

   outputUseDummyCheckBox->setChecked( false );
}

void HidroMainWindow::outputMGBRadioButton_clicked()
{
	outputUPLEFTLineEdit->setText( "64" );
	outputUPTLineEdit->setText( "128" );
	outputUPRIGHTLineEdit->setText( "1" );
	outputLEFTLineEdit->setText( "32" );
	outputPITLineEdit->setText( "0" );
	outputRIGHTLineEdit->setText( "2" );
	outputDOWNLEFTLineEdit->setText( "16" );
	outputDOWNTLineEdit->setText( "8" );
	outputDOWNRIGHTLineEdit->setText( "4" );
	outputDUMMYLineEdit->setText( "-9999" );

   outputUseDummyCheckBox->setChecked( true );
}

void HidroMainWindow::outputCustomRadioButton_clicked()
{
	outputUPLEFTLineEdit->setText( "" );
	outputUPTLineEdit->setText( "" );
	outputUPRIGHTLineEdit->setText( "" );
	outputLEFTLineEdit->setText( "" );
	outputPITLineEdit->setText( "" );
	outputRIGHTLineEdit->setText( "" );
	outputDOWNLEFTLineEdit->setText( "" );
	outputDOWNTLineEdit->setText( "" );
	outputDOWNRIGHTLineEdit->setText( "" );
	outputDUMMYLineEdit->setText( "" );

   outputUseDummyCheckBox->setChecked( false );
}

void HidroMainWindow::convertPushButton_clicked()
{
   int inputLDDmap[10];
	inputLDDmap[0] = inputUPLEFTLineEdit->text().toInt();
	inputLDDmap[1] = inputUPTLineEdit->text().toInt();
	inputLDDmap[2] = inputUPRIGHTLineEdit->text().toInt();
	inputLDDmap[3] = inputLEFTLineEdit->text().toInt();
	inputLDDmap[4] = inputPITLineEdit->text().toInt();
	inputLDDmap[5] = inputRIGHTLineEdit->text().toInt();
	inputLDDmap[6] = inputDOWNLEFTLineEdit->text().toInt();
	inputLDDmap[7] = inputDOWNTLineEdit->text().toInt();
	inputLDDmap[8] = inputDOWNRIGHTLineEdit->text().toInt();
	inputLDDmap[9] = inputDUMMYLineEdit	->text().toInt();

	int outputLDDmap[10];
	outputLDDmap[0] = outputUPLEFTLineEdit->text().toInt();
	outputLDDmap[1] = outputUPTLineEdit->text().toInt();
	outputLDDmap[2] = outputUPRIGHTLineEdit->text().toInt();
	outputLDDmap[3] = outputLEFTLineEdit->text().toInt();
	outputLDDmap[4] = outputPITLineEdit->text().toInt();
	outputLDDmap[5] = outputRIGHTLineEdit->text().toInt();
	outputLDDmap[6] = outputDOWNLEFTLineEdit->text().toInt();
	outputLDDmap[7] = outputDOWNTLineEdit->text().toInt();
	outputLDDmap[8] = outputDOWNRIGHTLineEdit->text().toInt();
	outputLDDmap[9] = outputDUMMYLineEdit	->text().toInt();

	std::string lddInputName = converterInputLDDComboBox->currentText().ascii();
	std::string lddOutputName = converterOutputLDDLineEdit->text().ascii();

   bool useDummy = outputUseDummyCheckBox->isChecked();

   int dataType = 1;

   if( outputTerraHidroRadioButton->isChecked() )
     dataType = 1;
   if( outputHandRadioButton->isChecked() )
     dataType = 2 ;
   if( outputMGBRadioButton->isChecked() )
     dataType = 3;
   if( outputCustomRadioButton->isChecked() )
     dataType = 4;

   convertLDD( _parameters->getCurrentDatabasePtr(), lddInputName, inputLDDmap, lddOutputName, outputLDDmap, dataType, useDummy );

   _parameters->updateTVInterface();
	QMessageBox::information(this, tr("Information"), tr("LDD Converted."));
}
