#include <QOpenModeller.h>

#include <progressForm.h>
#include <parametersWindow.h>

#include <qmessagebox.h>
#include <qfile.h>
#include <qlistbox.h>
#include <qlineedit.h>
#include <qprogressbar.h>
#include <qapplication.h>
#include <qtextbrowser.h> 

QOpenModeller::~QOpenModeller()
{	
	if( logCallback_ )
	{
		delete logCallback_;
		logCallback_ = 0;
	}

	if( parametersWindow_instance )
	{
    delete parametersWindow_instance;
		parametersWindow_instance = 0;
	}
	
	if(openModeller_)
	{
		delete openModeller_;
		openModeller_ = 0;
	}

	if(openModeller2_)
	{
		delete openModeller2_;
	}
}

/**
* Read paramteres from register.
*/
void QOpenModeller::readParametes( const QString algID )
{
	setAlgorithmParameters();
	parametersWindow_instance->ok();
	parametersWindow_instance->readParametes( algID );
}

/**
* Write paramteres in register.
*/
void QOpenModeller::writeParametes(  )
{
	parametersWindow_instance->writeParametes();
}



/**
* Run complet openModeller (Make modell and projection).
*/
void
QOpenModeller::run()
{
	int i, n_species;

	// Start Progress windows
	//progressForm progressWindows = new progressForm();
	progressForm progressWindows;
	progressWindows.show();

	Log::instance()->debug( "QOpenModeller::run: Inicializou a Janela de progresso.\n" );

	// Log
	logCallback_ = new QLogCallback();
	Log::instance()->setCallback( logCallback_ );
	Log::instance()->setLevel( Log::Debug );
	
	Log::instance()->debug( "QOpenModeller::run: Criou o logCallback_" );

	// Loop all species.
	n_species = speciesNames_.size();
	// Set progress bar total species.
	progressWindows.speciesTotalTextLabel->setText( QString("%1").arg( n_species ) );
	for(i=0; i<n_species; ++i)
	{
		Log::instance()->debug( "Entrou no for.\n" );
		bool flag_continue = true;

		// Log
		logCallback_->output_.clear();
		logCallback_->output_.setPointSize ( 12 );
		logCallback_->output_.setBold( false );
		logCallback_->append("<p>");
		logCallback_->append( tr("<h1> openModeller Report</h1>") );
		logCallback_->append( tr("<h2>Autogenerated using openModeller Plugin for TerraView</h2>") );
		logCallback_->append( "(c) A.Jardim 2006\n");

		// Start a new modeller.
		openModeller2_ = new OpenModeller();
		Log::instance()->debug( "Criou o openModeller.\n" );

		//Log
		logCallback_->append(   "<h3>" + QString(speciesNames_[i].c_str()) + "</h3>");
		logCallback_->append(   "<h2>Log of model run:</h2>");
		logCallback_->append( "Library version " );
		logCallback_->append( openModeller2_->getVersion().c_str() );
		logCallback_->append( "\n" );

		// Reset progress bars.
		progressWindows.projectionProgressBar->setProgress(-1);
		progressWindows.modelProgressBar->setProgress(-1);
		// Link progress windows to openModeller progress.
		openModeller2_->setModelCallback( progressBarCallback, progressWindows.modelProgressBar );
		openModeller2_->setMapCallback( progressBarCallback, progressWindows.projectionProgressBar );
		// Progress bar species count.
		progressWindows.speciesCountTextLabel->setText( QString("%1").arg( i+1 ) );

		// Occurrences
		progressWindows.specieTextLabel->setText( speciesNames_[i].c_str() );
		getOccurrences( speciesNames_[i].c_str() );
		Log::instance()->debug( "getOcurrences.\n" );

		// Enviroment
		openModeller2_->setEnvironment( categoricalMaps_, continuousMaps_, inputMask_ );
		Log::instance()->debug( "setEnviroment.\n" );

		// Projection
		setProjection();
		Log::instance()->debug( "setProjection.\n" );

		// Algorithm and Parameters.
		setAlgorithm();
		Log::instance()->debug( "setAlgorithm.\n" );

		// Make the model.
		try
		{
			openModeller2_->createModel();
		}
		catch ( ... )
		{
			QString aux( speciesNames_[i].c_str() );
			QMessageBox::information ( 0,
				"Open Modeller Plugin", "Species error:\nCheck the points for: " + aux + ".");
			flag_continue = false;
		}
		Log::instance()->debug( "CreateModel.\n" );

		if( flag_continue )
		{
			// Serialize model, if requested
			ConfigurationPtr cfg = openModeller2_->getModelConfiguration();
			Configuration::writeXml( cfg, xmlFileName_.c_str() );
			Log::instance()->debug( "Serialize.\n" );

			// Make the projection
			try
			{
				EnvironmentPtr env = createEnvironment( projectionCategoricalMaps_, projectionContinuousMaps_, outputMask_ );
				openModeller2_->createMap( env, projectionLayer_.c_str(), mapFormat_ );
			}
			catch ( ... ) {}
			Log::instance()->debug( "Projection.\n" );

			// Confusion matrix
			const ConfusionMatrix* matrix = openModeller2_->getConfusionMatrix();
			AreaStats* stats = openModeller2_->getActualAreaStats();
			Log::instance()->debug( "Matrix.\n" );
		
			//Log
			logCallback_->append( "<h2>Model statistics</h2>\n" );
			logCallback_->append( QString( "Accuracy: %1\%\n").arg( matrix->getAccuracy() * 100 ));
			logCallback_->append( QString( "Omission error:    %1\%\n").arg( matrix->getOmissionError() * 100 ));
			logCallback_->append(QString(  "Percentage of cells predicted present: %1\%\n").arg( 
				stats->getAreaPredictedPresent() / (double) stats->getTotalArea() * 100 ));
			logCallback_->append( QString( "Total number of cells: %1\n").arg( stats->getTotalArea() ));
		}
		
		// Report the modell in logCallback_->
		makeCofigureReport();
		Log::instance()->debug( "Report.\n" );

		QFile file( logFileName_ );
		if ( file.open( IO_WriteOnly ) ) 
		{
			QTextStream stream( &file );
			stream << logCallback_->output_.text();
			file.close();
		}

		// Make the configure file to om_console.
		makeConfigFile( speciesNames_[i].c_str() );

		delete openModeller2_;
		openModeller2_ = 0;
	}

	progressWindows.close();
//	delete progressWindows;
}

/**
* Make Configure File.
*/
void QOpenModeller::makeConfigFile( const string& specieName )
{
	int i, total;

	QFile myQFile( configureFileName_ );
	
	if ( myQFile.open( IO_WriteOnly ) )
	{
		QTextStream myQTextStream( &myQFile );
		//write the header to the file
		myQTextStream << tr("#######################################################################\n");
		myQTextStream << tr("##\n");
		myQTextStream << tr("##                openModeller Configuration file\n");
		myQTextStream << tr("##\n");
		myQTextStream << tr("## Autogenerated using openModeller Plugin for TerraView (c) INPE 2006\n");
		myQTextStream << tr("##\n");
		myQTextStream << tr("#######################################################################\n");
		myQTextStream << tr("\n\n##\n");                 
		myQTextStream << tr("## Coordinate system and projection in WKT format\n");
		myQTextStream << tr("##\n\n");        
		myQTextStream << tr("WKT Coord System = ") << projectionsMap_[ projection_ ] << "\n";

		myQTextStream << tr("\n\n##\n");                 
		myQTextStream << tr("## Localities Data Configuration Options...\n");
		myQTextStream << tr("##\n\n");
		myQTextStream << tr("# Full path and file name of the file containing localities data.\n");        
		myQTextStream << tr("Species file = ") << QString(speciesUrl_.c_str()) << "\n\n";
		myQTextStream << tr("# The taxon in the localities file to be modelled.\n");
		//myQTextStream << tr("# (Defaults to the first taxon found.)\n");
		myQTextStream << tr("Species = ") << QString(specieName.c_str()) << "\n";
		myQTextStream << tr("\n\n##\n");                 
		myQTextStream << tr("## Independent Variable Layers (map layers)\n");
		myQTextStream << tr("##\n\n");      
		
		// Iterate through the items in the layers list
		total = continuousMaps_.size();
		for (i=0; i< total; ++i)
		{          
			myQTextStream << tr("Map = ") << QString(continuousMaps_[i].c_str()) << "\n";
		}

		myQTextStream << tr("\n\n##\n"); 
		myQTextStream << tr("# A layer that specifies the region of interest for model building\n");      
		myQTextStream << tr("Mask = ") << QString(inputMask_.c_str()) << "\n";
		myQTextStream << tr("\n\n##\n");                                    
		myQTextStream << tr("## Model Output Settings\n");
		myQTextStream << tr("##\n\n");   

		myQTextStream << tr("## Map projection layers\n");     
		// Iterate through the items in the projection layers list
		total = projectionContinuousMaps_.size();
		for (i=0; i< total; ++i)
		{          
			myQTextStream << tr("Output map = ") << QString(projectionContinuousMaps_[i].c_str()) << "\n";
		}

		myQTextStream << tr("\n\n##\n");
		myQTextStream << tr("# A layer that specifies the region of interest for model projection\n");      
		myQTextStream << tr("Output Mask = ") << QString(outputMask_.c_str()) << "\n";

		myQTextStream << tr("\n\n##\n");
		myQTextStream << tr("# Output model name (serialized model)\n");
		myQTextStream << tr("Output model = ") << QString(xmlFileName_.c_str()) << "\n";

		myQTextStream << tr("\n\n##\n");
		myQTextStream << tr("# Output layer name\n");

		myQTextStream << tr("Output layer = ") << QString( projectionLayer_.c_str() ) << "\n";

		myQTextStream << tr("\n\n##\n"); 
		myQTextStream << tr("# A layer that specifies the format (cell size and coordinate system) for the generated map\n");      
		myQTextStream << tr("Output Format = ") << QString( outputFormat_.c_str() ) << "\n";
		myQTextStream << tr("\n\n##\n");                 
		myQTextStream << tr("## Model Type and Extra Model Parameters\n");
		myQTextStream << tr("##\n\n");         
		myQTextStream << tr("# Name of the algorithm used to construct the model.\n");
		myQTextStream << tr("Algorithm  = ");
		myQTextStream << algorithmID_ << "\n";
		// Iterate through the items in the extra parameters list
		for ( QStringList::Iterator myIterator = algorithmParameters_.begin(); myIterator != algorithmParameters_.end(); ++myIterator)
		{          
			myQTextStream << tr("Parameter = ") << *myIterator << "\n";
		}        

		myQTextStream << tr("\n\n###########################################\n");
		myQTextStream << tr("## End of autogenerated configuration file.\n");
		myQTextStream << tr("###########################################\n");
		//for ( QStringList::Iterator it = lines.begin(); it != lines.end(); ++it )
		//    myQTextStream << *it << "\n";
		myQFile.close();
	}
}

/**
* Make Configure Report.
*/
void QOpenModeller::makeCofigureReport()
{
	int i, total;

	//write the header to the file
	logCallback_->append( tr("<h2>Localities Data Configuration Options</h2>\n"));
	logCallback_->append( tr("<p><b>Coordinate system and projection in WKT format</b></p>\n"));
	logCallback_->append( "<p>" + projectionsMap_[ projection_ ] + "</p>\n");
	logCallback_->append( tr("<p><b>Full path and file name of the file containing localities data.</b></p>\n"));        
	logCallback_->append( "<p>" + QString(speciesUrl_.c_str()) + "</p>\n");
	logCallback_->append( tr("<h2>Independent Variable Layers (map layers)</h2>\n"));
	
	// Iterate through the items in the layers list
	logCallback_->append( "<ul>\n");
	total = continuousMaps_.size();
	for (i=0; i< total; ++i)
	{          
		logCallback_->append( "<li>" + QString(continuousMaps_[i].c_str()) + "</li>\n");
	}
	logCallback_->append( "</ul>\n");
	logCallback_->append( tr("<p><b>The mask layer that specifies the region of interest for model building</b></p>\n"));      
	logCallback_->append( "<p>"+ QString(inputMask_.c_str()) + "</p>\n");
	logCallback_->append( tr("<h2>Model Output Settings</h2\n"));
	logCallback_->append( tr("<h3>Map projection layers</h3>\n"));     
	
	// Iterate through the items in the projection layers list
	logCallback_->append( "<ul>\n");
	total = projectionContinuousMaps_.size();
	for (i=0; i< total; ++i)
	{          
		logCallback_->append( "<li>" + QString(projectionContinuousMaps_[i].c_str()) + "</li>\n");
	}
	logCallback_->append( "</ul>\n");
	logCallback_->append( tr("<p><b>The layer that specifies the region of interest for model projection</b></p>\n"));      
	logCallback_->append( "<p>" + QString(outputMask_.c_str()) + "</p>\n");

	logCallback_->append( tr("<p><b>Output model name (serialized model)</b></p>\n"));
	logCallback_->append( "<p>" + QString(xmlFileName_.c_str()) + "</p>\n");

	logCallback_->append( tr("<p><b>Output layer name</b></p>\n") );
	logCallback_->append( "<p>" + QString( projectionLayer_.c_str() ) + "</p>\n");
	logCallback_->append( tr("<p><b>The layer that specifies the format (cell size and coordinate system) for the generated map</b></p>\n"));      
	logCallback_->append( "<p>" + QString(outputFormat_.c_str()) + "</p>\n");
	logCallback_->append( tr("<h2> Model Type and Extra Model Parameters</h2>\n"));
	logCallback_->append( tr("<p><b>Name of the algorithm used to construct the model.</b></p>\n"));
	logCallback_->append( "<p>" + algorithmID_ + "</p>\n");
	logCallback_->append( tr("<p><b>Parameters used to control the algorithm.</b></p>\n") );
	// Iterate through the items in the extra parameters list
	logCallback_->append( "<ul>\n");
	for ( QStringList::Iterator myIterator = algorithmParameters_.begin(); myIterator != algorithmParameters_.end(); ++myIterator)
	{          
		logCallback_->append( "<li>" + *myIterator + "</li>\n");
	}        
	logCallback_->append( "</ul>\n");/**/
}

/**
* Set setAlgorithm and parameters.
*/
void
QOpenModeller::setAlgorithm()
{
	// Find out which model algorithm is to be used.
	AlgMetadata const *metadata;
	
	metadata = openModeller2_->algorithmMetadata( algorithmID_.latin1() );

	vector<string> req_param;

	int i = algorithmParameters_.size();

	QStringList::Iterator qsli = algorithmParameters_.begin();
	for(;qsli != algorithmParameters_.end(); ++qsli)
	{
		req_param.push_back( (*qsli).latin1() );
	}

	// For resulting parameters storage.
	int nparam = metadata->nparam;
	AlgParameter *param = new AlgParameter[nparam];

	AlgParamMetadata *algparam = metadata->param;
	AlgParamMetadata *end   = algparam + metadata->nparam;

	// For each algorithm parameter metadata...
	for ( ; algparam < end; algparam++, param++ )
	{

		// The resulting name is equal the name set in
		// algorithm's metadata.
		param->setId( algparam->id );

		// Read the resulting value from str_param.
		string value = extractParameter( param->id(), req_param );

		// If the parameter is not referenced in the file, set it
		// with the default value extracted from the parameter
		// metadata.
		if ( value.empty() )
			value = algparam->typical;

		param->setValue( value.c_str() );
	}
	param = param - nparam;

	// Set the model algorithm to be used by the controller
	openModeller2_->setAlgorithm( metadata->id, nparam, param );
}

/**
* Set projction maps.
*/
void
QOpenModeller::setProjection()
{
	mapFormat_ = MapFormat( outputFormat_.c_str() );
	mapFormat_.setFormat( MapFormat::GreyTiff );

	Raster* mask = RasterFactory::instance().create( outputMask_.c_str() );
	Header h = mask->header();
	mapFormat_.setXMin( h.xmin );
	mapFormat_.setYMin( h.ymin );
	mapFormat_.setXMax( h.xmax );
	mapFormat_.setYMax( h.ymax );
}

/**
* Get occurrences.
*/
void
QOpenModeller::getOccurrences( const string& oc_name )
{
	string oc_cs = projectionsMap_[ projection_ ];

	OccurrencesReader* oc_file =
		OccurrencesFactory::instance().create( speciesUrl_.c_str(), oc_cs.c_str() );

	openModeller2_->setOccurrences( oc_file->getPresences( oc_name.c_str() ) );

	// Add specie name with underline to output layer.
	QString aux = oc_name.c_str();
	aux.replace(' ','_');
	projectionLayer_ = projectionLayer_ + "_" +	aux.latin1();
	// Set the log file name.
	int i = projectionLayer_.find_last_of(">");
	logFileName_ = outputDirectoryName_ + "/" +
		QString(projectionLayer_.substr(i+1,projectionLayer_.length()).c_str())
		+ ".html";
	// Set the configure file name.
	configureFileName_ = outputDirectoryName_ + "/" +
		QString(projectionLayer_.substr(i+1,projectionLayer_.length()).c_str())
		+ ".cfg";
	// Set the xml file name.
	xmlFileName_ = outputDirectoryName_ + "/" +
		QString(projectionLayer_.substr(i+1,projectionLayer_.length()).c_str())
		+ ".xml";
}

/**
* Get avaliable algorithms.
*/
void
QOpenModeller::getAlgorithmList( QComboBox* algorithmComboBox )
{
	// Find algorithms dlls.
	AlgorithmFactory::searchDefaultDirs();
	
	// Find out which model algorithm is to be used.
	const AlgMetadata **myAlgorithmMetadataArray = openModeller_->availableAlgorithms();
	const AlgMetadata *myAlgorithmMetadata;
	
	//loop through the algorithm names adding to the algs combo
	QStringList alglist;
	while ( myAlgorithmMetadata = *myAlgorithmMetadataArray++ )
	{
		alglist.append( myAlgorithmMetadata->name.c_str() );
	}

	alglist.sort();

	for ( QStringList::Iterator it = alglist.begin(); it != alglist.end(); ++it ) 
	{
		algorithmComboBox->insertItem(*it);
	}

	algorithmID_ = alglist[0];

	Log::instance()->debug( algorithmID_.ascii() );
	Log::instance()->debug( "\n" );

	// Default parameters
	parametersWindow_instance->getParameterList( algorithmID_ );
	changeAlgorithm( algorithmComboBox->currentText() );
	parametersWindow_instance->okPushButton_clicked();
}
/**
* Change the model algotithm.
*/
void
QOpenModeller::changeAlgorithm( const QString &algorithmComboText )
{
	const AlgMetadata **myAlgorithmsMetadataArray = openModeller_->availableAlgorithms();
	const AlgMetadata *myAlgorithmMetadata;

	while ( myAlgorithmMetadata = *myAlgorithmsMetadataArray++ )
	{
		QString myAlgorithmNameQString=myAlgorithmMetadata->name.c_str();
		if (myAlgorithmNameQString==algorithmComboText)
		{
			algorithmID_ = myAlgorithmMetadata->id.c_str();
			//txtVersion->setText(myAlgorithmMetadata->version);
			//txtAuthor->setText(myAlgorithmMetadata->author);
			//txtAlgorithmDescription->setText(myAlgorithmMetadata->description);
			//txtBibliography->setText(myAlgorithmMetadata->biblio);
		}
	}
}
/**
* Set the algorthm parameters.
*/
void
QOpenModeller::setAlgorithmParameters()
{
	if( lastAlgorithmID_.compare(algorithmID_) )
		parametersWindow_instance->getParameterList( algorithmID_ );

	lastAlgorithmID_ = algorithmID_;
	
	parametersWindow_instance->show();
}
/**
* Extract the parameter value.
*/
string
QOpenModeller::extractParameter( string const name, vector<string> vet )
{
	int length = name.length();
	vector<string>::iterator it = vet.begin();
	vector<string>::iterator end = vet.end();

	while ( it != end )
	{
		if ( name == (*it).substr(0, length) )
		{
			return (*it).substr( length );
		}
		++it;
	}

	return "";
}

/**
* Get Projections list.
*/
void
QOpenModeller::getProjList( QComboBox* projectionComboBox )
{
	//first some hard coded options 
	projectionsMap_["Lat/Long WGS84"] = "GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9108\"]],AXIS[\"Lat\",NORTH],AXIS[\"Long\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]";
	projectionsMap_["Lat/Long 1924 Brazil"] =  "GEOGCS[\"1924 ellipsoid\", DATUM[\"Not_specified\", SPHEROID[\"International 1924\",6378388,297,AUTHORITY[\"EPSG\",\"7022\"]], AUTHORITY[\"EPSG","6022\"]], PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]], UNIT[\"degree\",0.0174532925199433, AUTHORITY[\"EPSG","9108\"]], AUTHORITY[\"EPSG","4022\"]]";
	projectionsMap_["UTM Zone 22 - Datum: Corrego Alegre"] = "UTM Zone 22 - Datum: Corrego Alegre: PROJCS[\"UTM Zone 22, Southern Hemisphere\", GEOGCS[\"Datum Corrego Alegre\", DATUM[\"Datum Corrego Alegre\", SPHEROID[\"International 1924\",6378388,297,AUTHORITY[\"EPSG","7022\"]], AUTHORITY[\"EPSG\",\"6022\"]], PRIMEM[\"Greenwich\",0, AUTHORITY[\"EPSG\",\"8901\"]], UNIT[\"degree\",0.0174532925199433, AUTHORITY[\"EPSG\",\"9108\"]], AUTHORITY[\"EPSG\",\"4022\"]], PROJECTION[\"Transverse_Mercator\"], PARAMETER[\"latitude_of_origin\",0], PARAMETER[\"central_meridian\",-51], PARAMETER[\"scale_factor\",0.9996], PARAMETER[\"false_easting\",500000], PARAMETER[\"false_northing\",10000000], UNIT[\"METERS\",1]]";
	projectionsMap_["Long/Lat - Datum: Corrego Alegre"] = "GEOGCS[\"Datum Corrego Alegre\", DATUM[\"Datum Corrego Alegre\", SPHEROID[\"International 1924\",6378388,297,AUTHORITY[\"EPSG\",\"7022\"]], AUTHORITY[\"EPSG\",\"6022\"]], PRIMEM[\"Greenwich\",0, AUTHORITY[\"EPSG\",\"8901\"]], UNIT[\"degree\",0.0174532925199433, AUTHORITY[\"EPSG\",\"9108\"]], AUTHORITY[\"EPSG\",\"4022\"]]";

	projectionComboBox->insertItem("Lat/Long WGS84");
	projectionComboBox->insertItem("Lat/Long 1924 Brazil");
	projectionComboBox->insertItem("UTM Zone 22 - Datum: Corrego Alegre");
	projectionComboBox->insertItem("Long/Lat - Datum: Corrego Alegre");

	//*
	#ifdef WIN32
		QString theFileNameQString = "wkt_defs.txt";
	#else
		#ifdef Q_OS_MACX
			QString theFileNameQString = qApp->applicationDirPath() + "/share/qgis";
		#else
			QString theFileNameQString = QGISDATAPATH;
		#endif
		theFileNameQString += "/wkt_defs.txt";
	#endif

	QFile myQFile( theFileNameQString );
	if ( myQFile.open( IO_ReadOnly ) ) 
	{
		//clear the existing entries in the taxon combo first
		//cboCoordinateSystem->clear();     
		//now we parse the loc file, checking each line for its taxon
		QTextStream myQTextStream( &myQFile );
		QString myCurrentLineQString;
		QStringList myQStringList;
		while ( !myQTextStream.atEnd() ) 
		{
			myCurrentLineQString = myQTextStream.readLine(); // line of text excluding '\n'
			if (myCurrentLineQString.left(4)!="PROJ")
			{
				QString myNextLineQString = myQTextStream.readLine(); // lthis is the actual wkt string
				if (myNextLineQString.left(4)!="PROJ") //the line shoue start with PROJ
				{
					continue;
				}
				//#ifdef QGISDEBUG
				//std::cout << " Match found:" << myCurrentLineQString.ascii() << std::endl;
				//#endif
				projectionsMap_[myCurrentLineQString]=myNextLineQString;
			}
		}
		myQFile.close();
		//no add each key to our combo
		ProjectionWKTMap::Iterator myIterator;
		for ( myIterator = projectionsMap_.begin(); myIterator != projectionsMap_.end(); ++myIterator ) 
		{
			projectionComboBox->insertItem(myIterator.key());
		}
	}
	else
	{
		QMessageBox::warning( parent_, QString("openModeller Wizard Error"), QString("The projections file is not readable. Check you have the neccessary file permissions and try again. Only a small list of projections is now availiable.") );      
		ProjectionWKTMap::Iterator myIterator;
		for ( myIterator = projectionsMap_.begin(); myIterator != projectionsMap_.end(); ++myIterator ) 
		{
			projectionComboBox->insertItem(myIterator.key());
		}
	} 
	//*/
	projectionComboBox->setCurrentText("Lat/Long WGS84");
}

/**
* openModeller progress communication.
*/
void 
QOpenModeller::progressBarCallback( float progress, void *extra_param )
{
	QProgressBar *myProgressBar = (QProgressBar *) extra_param;
	myProgressBar->setProgress((int)(100 * progress));
	qApp->processEvents();
}

/**
* Default constructor.
*/
QOpenModeller::QOpenModeller( QWidget* parent ) : 
	parent_(parent),
	openModeller_( new OpenModeller ),
	openModeller2_( 0 ),
	logCallback_( 0 )
{
  // Log
	//X
	//Log::instance()->setCallback( logCallback_ );
	//Log::instance()->setLevel( Log::Debug );

	lastAlgorithmID_ = "not";
	parametersWindow_instance = 0; 
	parametersWindow_instance = new parametersWindow( &algorithmParameters_ );
};
